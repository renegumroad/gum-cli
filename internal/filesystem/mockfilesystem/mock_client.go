// Code generated by mockery v2.43.2. DO NOT EDIT.

package mockfilesystem

import (
	filesystem "github.com/renegumroad/gum-cli/internal/filesystem"
	mock "github.com/stretchr/testify/mock"
)

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

type MockClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClient) EXPECT() *MockClient_Expecter {
	return &MockClient_Expecter{mock: &_m.Mock}
}

// AppendString provides a mock function with given fields: path, content
func (_m *MockClient) AppendString(path string, content string) error {
	ret := _m.Called(path, content)

	if len(ret) == 0 {
		panic("no return value specified for AppendString")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(path, content)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_AppendString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendString'
type MockClient_AppendString_Call struct {
	*mock.Call
}

// AppendString is a helper method to define mock.On call
//   - path string
//   - content string
func (_e *MockClient_Expecter) AppendString(path interface{}, content interface{}) *MockClient_AppendString_Call {
	return &MockClient_AppendString_Call{Call: _e.mock.On("AppendString", path, content)}
}

func (_c *MockClient_AppendString_Call) Run(run func(path string, content string)) *MockClient_AppendString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockClient_AppendString_Call) Return(_a0 error) *MockClient_AppendString_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_AppendString_Call) RunAndReturn(run func(string, string) error) *MockClient_AppendString_Call {
	_c.Call.Return(run)
	return _c
}

// Chown provides a mock function with given fields: path, uid, gid
func (_m *MockClient) Chown(path string, uid int, gid int) error {
	ret := _m.Called(path, uid, gid)

	if len(ret) == 0 {
		panic("no return value specified for Chown")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int, int) error); ok {
		r0 = rf(path, uid, gid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_Chown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Chown'
type MockClient_Chown_Call struct {
	*mock.Call
}

// Chown is a helper method to define mock.On call
//   - path string
//   - uid int
//   - gid int
func (_e *MockClient_Expecter) Chown(path interface{}, uid interface{}, gid interface{}) *MockClient_Chown_Call {
	return &MockClient_Chown_Call{Call: _e.mock.On("Chown", path, uid, gid)}
}

func (_c *MockClient_Chown_Call) Run(run func(path string, uid int, gid int)) *MockClient_Chown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockClient_Chown_Call) Return(_a0 error) *MockClient_Chown_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_Chown_Call) RunAndReturn(run func(string, int, int) error) *MockClient_Chown_Call {
	_c.Call.Return(run)
	return _c
}

// ChownUser provides a mock function with given fields: path, uid
func (_m *MockClient) ChownUser(path string, uid int) error {
	ret := _m.Called(path, uid)

	if len(ret) == 0 {
		panic("no return value specified for ChownUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int) error); ok {
		r0 = rf(path, uid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_ChownUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChownUser'
type MockClient_ChownUser_Call struct {
	*mock.Call
}

// ChownUser is a helper method to define mock.On call
//   - path string
//   - uid int
func (_e *MockClient_Expecter) ChownUser(path interface{}, uid interface{}) *MockClient_ChownUser_Call {
	return &MockClient_ChownUser_Call{Call: _e.mock.On("ChownUser", path, uid)}
}

func (_c *MockClient_ChownUser_Call) Run(run func(path string, uid int)) *MockClient_ChownUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int))
	})
	return _c
}

func (_c *MockClient_ChownUser_Call) Return(_a0 error) *MockClient_ChownUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_ChownUser_Call) RunAndReturn(run func(string, int) error) *MockClient_ChownUser_Call {
	_c.Call.Return(run)
	return _c
}

// CopyFile provides a mock function with given fields: source, destination
func (_m *MockClient) CopyFile(source string, destination string) error {
	ret := _m.Called(source, destination)

	if len(ret) == 0 {
		panic("no return value specified for CopyFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(source, destination)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CopyFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyFile'
type MockClient_CopyFile_Call struct {
	*mock.Call
}

// CopyFile is a helper method to define mock.On call
//   - source string
//   - destination string
func (_e *MockClient_Expecter) CopyFile(source interface{}, destination interface{}) *MockClient_CopyFile_Call {
	return &MockClient_CopyFile_Call{Call: _e.mock.On("CopyFile", source, destination)}
}

func (_c *MockClient_CopyFile_Call) Run(run func(source string, destination string)) *MockClient_CopyFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockClient_CopyFile_Call) Return(_a0 error) *MockClient_CopyFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CopyFile_Call) RunAndReturn(run func(string, string) error) *MockClient_CopyFile_Call {
	_c.Call.Return(run)
	return _c
}

// CurrentDir provides a mock function with given fields:
func (_m *MockClient) CurrentDir() (string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CurrentDir")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_CurrentDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrentDir'
type MockClient_CurrentDir_Call struct {
	*mock.Call
}

// CurrentDir is a helper method to define mock.On call
func (_e *MockClient_Expecter) CurrentDir() *MockClient_CurrentDir_Call {
	return &MockClient_CurrentDir_Call{Call: _e.mock.On("CurrentDir")}
}

func (_c *MockClient_CurrentDir_Call) Run(run func()) *MockClient_CurrentDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockClient_CurrentDir_Call) Return(_a0 string, _a1 error) *MockClient_CurrentDir_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_CurrentDir_Call) RunAndReturn(run func() (string, error)) *MockClient_CurrentDir_Call {
	_c.Call.Return(run)
	return _c
}

// EnsureNonSudoOwnership provides a mock function with given fields: path
func (_m *MockClient) EnsureNonSudoOwnership(path string) error {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for EnsureNonSudoOwnership")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_EnsureNonSudoOwnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureNonSudoOwnership'
type MockClient_EnsureNonSudoOwnership_Call struct {
	*mock.Call
}

// EnsureNonSudoOwnership is a helper method to define mock.On call
//   - path string
func (_e *MockClient_Expecter) EnsureNonSudoOwnership(path interface{}) *MockClient_EnsureNonSudoOwnership_Call {
	return &MockClient_EnsureNonSudoOwnership_Call{Call: _e.mock.On("EnsureNonSudoOwnership", path)}
}

func (_c *MockClient_EnsureNonSudoOwnership_Call) Run(run func(path string)) *MockClient_EnsureNonSudoOwnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockClient_EnsureNonSudoOwnership_Call) Return(_a0 error) *MockClient_EnsureNonSudoOwnership_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_EnsureNonSudoOwnership_Call) RunAndReturn(run func(string) error) *MockClient_EnsureNonSudoOwnership_Call {
	_c.Call.Return(run)
	return _c
}

// EqualFiles provides a mock function with given fields: source, destination
func (_m *MockClient) EqualFiles(source string, destination string) (bool, error) {
	ret := _m.Called(source, destination)

	if len(ret) == 0 {
		panic("no return value specified for EqualFiles")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (bool, error)); ok {
		return rf(source, destination)
	}
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(source, destination)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(source, destination)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_EqualFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EqualFiles'
type MockClient_EqualFiles_Call struct {
	*mock.Call
}

// EqualFiles is a helper method to define mock.On call
//   - source string
//   - destination string
func (_e *MockClient_Expecter) EqualFiles(source interface{}, destination interface{}) *MockClient_EqualFiles_Call {
	return &MockClient_EqualFiles_Call{Call: _e.mock.On("EqualFiles", source, destination)}
}

func (_c *MockClient_EqualFiles_Call) Run(run func(source string, destination string)) *MockClient_EqualFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockClient_EqualFiles_Call) Return(_a0 bool, _a1 error) *MockClient_EqualFiles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_EqualFiles_Call) RunAndReturn(run func(string, string) (bool, error)) *MockClient_EqualFiles_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function with given fields: path
func (_m *MockClient) Exists(path string) bool {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockClient_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockClient_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - path string
func (_e *MockClient_Expecter) Exists(path interface{}) *MockClient_Exists_Call {
	return &MockClient_Exists_Call{Call: _e.mock.On("Exists", path)}
}

func (_c *MockClient_Exists_Call) Run(run func(path string)) *MockClient_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockClient_Exists_Call) Return(_a0 bool) *MockClient_Exists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_Exists_Call) RunAndReturn(run func(string) bool) *MockClient_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// GetOwner provides a mock function with given fields: path
func (_m *MockClient) GetOwner(path string) (*filesystem.UserInfo, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for GetOwner")
	}

	var r0 *filesystem.UserInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*filesystem.UserInfo, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) *filesystem.UserInfo); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*filesystem.UserInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetOwner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOwner'
type MockClient_GetOwner_Call struct {
	*mock.Call
}

// GetOwner is a helper method to define mock.On call
//   - path string
func (_e *MockClient_Expecter) GetOwner(path interface{}) *MockClient_GetOwner_Call {
	return &MockClient_GetOwner_Call{Call: _e.mock.On("GetOwner", path)}
}

func (_c *MockClient_GetOwner_Call) Run(run func(path string)) *MockClient_GetOwner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockClient_GetOwner_Call) Return(_a0 *filesystem.UserInfo, _a1 error) *MockClient_GetOwner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetOwner_Call) RunAndReturn(run func(string) (*filesystem.UserInfo, error)) *MockClient_GetOwner_Call {
	_c.Call.Return(run)
	return _c
}

// HomeDir provides a mock function with given fields:
func (_m *MockClient) HomeDir() (string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for HomeDir")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_HomeDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HomeDir'
type MockClient_HomeDir_Call struct {
	*mock.Call
}

// HomeDir is a helper method to define mock.On call
func (_e *MockClient_Expecter) HomeDir() *MockClient_HomeDir_Call {
	return &MockClient_HomeDir_Call{Call: _e.mock.On("HomeDir")}
}

func (_c *MockClient_HomeDir_Call) Run(run func()) *MockClient_HomeDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockClient_HomeDir_Call) Return(_a0 string, _a1 error) *MockClient_HomeDir_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_HomeDir_Call) RunAndReturn(run func() (string, error)) *MockClient_HomeDir_Call {
	_c.Call.Return(run)
	return _c
}

// IsDir provides a mock function with given fields: path
func (_m *MockClient) IsDir(path string) bool {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for IsDir")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockClient_IsDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsDir'
type MockClient_IsDir_Call struct {
	*mock.Call
}

// IsDir is a helper method to define mock.On call
//   - path string
func (_e *MockClient_Expecter) IsDir(path interface{}) *MockClient_IsDir_Call {
	return &MockClient_IsDir_Call{Call: _e.mock.On("IsDir", path)}
}

func (_c *MockClient_IsDir_Call) Run(run func(path string)) *MockClient_IsDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockClient_IsDir_Call) Return(_a0 bool) *MockClient_IsDir_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_IsDir_Call) RunAndReturn(run func(string) bool) *MockClient_IsDir_Call {
	_c.Call.Return(run)
	return _c
}

// IsExecutable provides a mock function with given fields: path
func (_m *MockClient) IsExecutable(path string) bool {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for IsExecutable")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockClient_IsExecutable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsExecutable'
type MockClient_IsExecutable_Call struct {
	*mock.Call
}

// IsExecutable is a helper method to define mock.On call
//   - path string
func (_e *MockClient_Expecter) IsExecutable(path interface{}) *MockClient_IsExecutable_Call {
	return &MockClient_IsExecutable_Call{Call: _e.mock.On("IsExecutable", path)}
}

func (_c *MockClient_IsExecutable_Call) Run(run func(path string)) *MockClient_IsExecutable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockClient_IsExecutable_Call) Return(_a0 bool) *MockClient_IsExecutable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_IsExecutable_Call) RunAndReturn(run func(string) bool) *MockClient_IsExecutable_Call {
	_c.Call.Return(run)
	return _c
}

// IsFile provides a mock function with given fields: path
func (_m *MockClient) IsFile(path string) bool {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for IsFile")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockClient_IsFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsFile'
type MockClient_IsFile_Call struct {
	*mock.Call
}

// IsFile is a helper method to define mock.On call
//   - path string
func (_e *MockClient_Expecter) IsFile(path interface{}) *MockClient_IsFile_Call {
	return &MockClient_IsFile_Call{Call: _e.mock.On("IsFile", path)}
}

func (_c *MockClient_IsFile_Call) Run(run func(path string)) *MockClient_IsFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockClient_IsFile_Call) Return(_a0 bool) *MockClient_IsFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_IsFile_Call) RunAndReturn(run func(string) bool) *MockClient_IsFile_Call {
	_c.Call.Return(run)
	return _c
}

// IsSymlink provides a mock function with given fields: path
func (_m *MockClient) IsSymlink(path string) bool {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for IsSymlink")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockClient_IsSymlink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsSymlink'
type MockClient_IsSymlink_Call struct {
	*mock.Call
}

// IsSymlink is a helper method to define mock.On call
//   - path string
func (_e *MockClient_Expecter) IsSymlink(path interface{}) *MockClient_IsSymlink_Call {
	return &MockClient_IsSymlink_Call{Call: _e.mock.On("IsSymlink", path)}
}

func (_c *MockClient_IsSymlink_Call) Run(run func(path string)) *MockClient_IsSymlink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockClient_IsSymlink_Call) Return(_a0 bool) *MockClient_IsSymlink_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_IsSymlink_Call) RunAndReturn(run func(string) bool) *MockClient_IsSymlink_Call {
	_c.Call.Return(run)
	return _c
}

// MakeExecutable provides a mock function with given fields: path
func (_m *MockClient) MakeExecutable(path string) error {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for MakeExecutable")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_MakeExecutable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MakeExecutable'
type MockClient_MakeExecutable_Call struct {
	*mock.Call
}

// MakeExecutable is a helper method to define mock.On call
//   - path string
func (_e *MockClient_Expecter) MakeExecutable(path interface{}) *MockClient_MakeExecutable_Call {
	return &MockClient_MakeExecutable_Call{Call: _e.mock.On("MakeExecutable", path)}
}

func (_c *MockClient_MakeExecutable_Call) Run(run func(path string)) *MockClient_MakeExecutable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockClient_MakeExecutable_Call) Return(_a0 error) *MockClient_MakeExecutable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_MakeExecutable_Call) RunAndReturn(run func(string) error) *MockClient_MakeExecutable_Call {
	_c.Call.Return(run)
	return _c
}

// MkdirAll provides a mock function with given fields: path
func (_m *MockClient) MkdirAll(path string) error {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for MkdirAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_MkdirAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MkdirAll'
type MockClient_MkdirAll_Call struct {
	*mock.Call
}

// MkdirAll is a helper method to define mock.On call
//   - path string
func (_e *MockClient_Expecter) MkdirAll(path interface{}) *MockClient_MkdirAll_Call {
	return &MockClient_MkdirAll_Call{Call: _e.mock.On("MkdirAll", path)}
}

func (_c *MockClient_MkdirAll_Call) Run(run func(path string)) *MockClient_MkdirAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockClient_MkdirAll_Call) Return(_a0 error) *MockClient_MkdirAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_MkdirAll_Call) RunAndReturn(run func(string) error) *MockClient_MkdirAll_Call {
	_c.Call.Return(run)
	return _c
}

// MkdirTemp provides a mock function with given fields:
func (_m *MockClient) MkdirTemp() (string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MkdirTemp")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_MkdirTemp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MkdirTemp'
type MockClient_MkdirTemp_Call struct {
	*mock.Call
}

// MkdirTemp is a helper method to define mock.On call
func (_e *MockClient_Expecter) MkdirTemp() *MockClient_MkdirTemp_Call {
	return &MockClient_MkdirTemp_Call{Call: _e.mock.On("MkdirTemp")}
}

func (_c *MockClient_MkdirTemp_Call) Run(run func()) *MockClient_MkdirTemp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockClient_MkdirTemp_Call) Return(_a0 string, _a1 error) *MockClient_MkdirTemp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_MkdirTemp_Call) RunAndReturn(run func() (string, error)) *MockClient_MkdirTemp_Call {
	_c.Call.Return(run)
	return _c
}

// RootDir provides a mock function with given fields:
func (_m *MockClient) RootDir() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for RootDir")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockClient_RootDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootDir'
type MockClient_RootDir_Call struct {
	*mock.Call
}

// RootDir is a helper method to define mock.On call
func (_e *MockClient_Expecter) RootDir() *MockClient_RootDir_Call {
	return &MockClient_RootDir_Call{Call: _e.mock.On("RootDir")}
}

func (_c *MockClient_RootDir_Call) Run(run func()) *MockClient_RootDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockClient_RootDir_Call) Return(_a0 string) *MockClient_RootDir_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_RootDir_Call) RunAndReturn(run func() string) *MockClient_RootDir_Call {
	_c.Call.Return(run)
	return _c
}

// WriteString provides a mock function with given fields: path, content
func (_m *MockClient) WriteString(path string, content string) error {
	ret := _m.Called(path, content)

	if len(ret) == 0 {
		panic("no return value specified for WriteString")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(path, content)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_WriteString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteString'
type MockClient_WriteString_Call struct {
	*mock.Call
}

// WriteString is a helper method to define mock.On call
//   - path string
//   - content string
func (_e *MockClient_Expecter) WriteString(path interface{}, content interface{}) *MockClient_WriteString_Call {
	return &MockClient_WriteString_Call{Call: _e.mock.On("WriteString", path, content)}
}

func (_c *MockClient_WriteString_Call) Run(run func(path string, content string)) *MockClient_WriteString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockClient_WriteString_Call) Return(_a0 error) *MockClient_WriteString_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_WriteString_Call) RunAndReturn(run func(string, string) error) *MockClient_WriteString_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClient {
	mock := &MockClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
